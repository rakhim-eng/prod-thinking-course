<script src="./gtm.html"></script>
<script src="/lessons/gtm.html"></script>
# Инженерное мышление в продакшене

## Урок 9: Разбор race condition в платежах

Два пользователя одновременно кликают оплатить один товар. Деньги списываются дважды. Или заказ создаётся дважды. Платёжный шлюз ругается на дубли. Клиенты звонят в поддержку. Классический race condition в критической зоне. Проявляется редко но всегда болезненно.

Такие баги прячутся в асинхронных операциях. Пользователь кликает кнопку. Frontend отправляет запрос. Backend проверяет остаток товара. Списывает деньги. Создаёт заказ. Если два запроса приходят параллельно проверка остатка проходит для обоих. Оба списывают.

Первый признак concurrency проблемы повторяемость под нагрузкой. В одиночку всё работает. При ста параллельных запросах баги вылазят. Тестировать нужно именно под нагрузкой.

Второй способ ловли добавить логирование ключевых шагов. Timestamp когда пришла проверка остатка. Когда списали деньги. Когда создали заказ. Сравни последовательность для дублей. Увидишь где пересеклись.

Третий паттерн optimistic locking. Добавь версию к заказу или товару. При обновлении проверяй что версия не изменилась. Если изменилась отклоняй вторую операцию. Простое решение для большинства race conditions.

Четвёртый database level. Используй SELECT FOR UPDATE. Или уникальные constraints на комбинацию user id order id. База сама заблокирует параллельные изменения.

Пятый fallback стратегия. Даже с фиксом готовь план B. Если race condition прорвался компенсируй. Верни деньги. Отмени дубль заказа. Автоматизируй где возможно.

Шестой мониторинг. Добавь алерт на дубль заказов. Или двойное списание. Метрика должна ловить проблему раньше поддержки.

Race conditions особенно опасны в финансах. Один дубль пятьдесят рублей терпимо. Тысяча дублей пятьсот тысяч уже катастрофа. Фиксить нужно на уровне архитектуры. Не только кодом.
